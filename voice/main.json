{"meta":{"generator":"0.12.0","format":30,"date":1658680423894},"classes":[{"name":"AudioPlayer","description":"Used to play audio resources (i.e. tracks, streams) to voice connections.","extends":[[["EventEmitter"]]],"construct":{"name":"new AudioPlayer","description":"Creates a new AudioPlayer.","params":[{"name":"options","optional":true,"default":"{}","type":[[["CreateAudioPlayerOptions"]]]}]},"props":[{"name":"_state","description":"The state that the AudioPlayer is in.","access":"private","type":[[["AudioPlayerState"]]],"meta":{"line":212,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L212"}},{"name":"behaviors","description":"The behavior that the player should follow when it enters certain situations.","access":"private","readonly":true,"type":[[["{"],["\nmaxMissedFrames",": "],["number",","],["\nnoSubscriber",": "],["NoSubscriberBehavior\n","}"]]],"meta":{"line":223,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L223"}},{"name":"debug","description":"The debug logger function, if debugging is enabled.","access":"private","readonly":true,"type":[[["null"," | ("],["message",": "],["string",") => "],["void"]]],"meta":{"line":231,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L231"}},{"name":"subscribers","description":"A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio\nto the streams in this list.","access":"private","readonly":true,"default":"[]","type":[[["Array","<"],["PlayerSubscription",">"]]],"meta":{"line":218,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L218"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":291,"file":"events.d.ts"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":296,"file":"events.d.ts"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":297,"file":"events.d.ts"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":290,"file":"events.d.ts"}}],"methods":[{"name":"_preparePacket","description":"Instructs the given connections to each prepare this packet to be played at the start of the\nnext cycle.","access":"private","params":[{"name":"packet","description":"The Opus packet to be prepared by each receiver","optional":false,"type":[[["Buffer"]]]},{"name":"receivers","description":"The connections that should play this packet","optional":false,"type":[[["Array","<"],["VoiceConnection",">"]]]},{"name":"state","optional":false,"type":[[["AudioPlayerPlayingState"," | "],["AudioPlayerPausedState"]]]}],"returns":[[[["void"]]]],"meta":{"line":625,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L625"}},{"name":"_signalStopSpeaking","description":"Signals to all the subscribed connections that they should send a packet to Discord indicating\nthey are no longer speaking. Called once playback of a resource ends.","access":"private","returns":[[[["void"]]]],"meta":{"line":614,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L614"}},{"name":"_stepDispatch","description":"Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered\nby the active connections of this audio player.","access":"private","returns":[[[["void"]]]],"meta":{"line":526,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L526"}},{"name":"_stepPrepare","description":"Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the\nunderlying resource of the stream, and then has all the active connections of the audio player prepare it\n(encrypt it, append header data) so that it is ready to play at the start of the next cycle.","access":"private","returns":[[[["void"]]]],"meta":{"line":542,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L542"}},{"name":"addListener","description":"Alias for `emitter.on(eventName, listener)`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":317,"file":"events.d.ts"}},{"name":"checkPlayable","description":"Checks whether the underlying resource (if any) is playable (readable)","returns":[{"types":[[["boolean"]]],"description":"`true` if the resource is playable, otherwise `false`"}],"returnsDescription":"`true` if the resource is playable, otherwise `false`","meta":{"line":507,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L507"}},{"name":"emit","description":"Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nconst EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"args","optional":false,"variable":true,"type":[[["Array","<"],["any",">"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":573,"file":"events.d.ts"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nconst EventEmitter = require('events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```","returns":[[[["Array","<"],["string"," | "],["symbol",">"]]]],"meta":{"line":632,"file":"events.d.ts"}},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to defaultMaxListeners.","returns":[[[["number"]]]],"meta":{"line":489,"file":"events.d.ts"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":579,"file":"events.d.ts"}},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":502,"file":"events.d.ts"}},{"name":"off","description":"Alias for `emitter.removeListener()`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":462,"file":"events.d.ts"}},{"name":"once","description":"Adds a **one-time**`listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":377,"file":"events.d.ts"}},{"name":"pause","description":"Pauses playback of the current resource, if any.","params":[{"name":"interpolateSilence","description":"If true, the player will play 5 packets of silence after pausing to prevent audio glitches","optional":true,"default":"true","type":[[["boolean"]]]}],"returns":[{"types":[[["boolean"]]],"description":"`true` if the player was successfully paused, otherwise `false`"}],"returnsDescription":"`true` if the player was successfully paused, otherwise `false`","meta":{"line":457,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L457"}},{"name":"play","description":"Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed\n(it cannot be reused, even in another player) and is replaced with the new resource.","params":[{"name":"resource","description":"The resource to play","optional":false,"type":[[["AudioResource","<"],["T",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":376,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L376"}},{"name":"prependListener","description":"Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\ntimes.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":597,"file":"events.d.ts"}},{"name":"prependOnceListener","description":"Adds a **one-time**`listener` function for the event named `eventName` to the_beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":613,"file":"events.d.ts"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":532,"file":"events.d.ts"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":473,"file":"events.d.ts"}},{"name":"removeListener","description":"Removes the specified `listener` from the listener array for the event named`eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will\nnot remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')`listener is removed:\n\n```js\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":457,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":483,"file":"events.d.ts"}},{"name":"stop","description":"Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,\nor remain in its current state until the silence padding frames of the resource have been played.","params":[{"name":"force","description":"If true, will force the player to enter the Idle state even if the resource has silence padding frames","optional":true,"default":"false","type":[[["boolean"]]]}],"returns":[{"types":[[["boolean"]]],"description":"`true` if the player will come to a stop, otherwise `false`"}],"returnsDescription":"`true` if the player will come to a stop, otherwise `false`","meta":{"line":490,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L490"}},{"name":"subscribe","description":"Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,\nthen the existing subscription is used.","access":"private","params":[{"name":"connection","description":"The connection to subscribe","optional":false,"type":[[["VoiceConnection"]]]}],"returns":[{"types":[[["PlayerSubscription"]]],"description":"The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription"}],"returnsDescription":"The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription","meta":{"line":268,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L268"}},{"name":"unpause","description":"Unpauses playback of the current resource, if any.","returns":[{"types":[[["boolean"]]],"description":"`true` if the player was successfully unpaused, otherwise `false`"}],"returnsDescription":"`true` if the player was successfully unpaused, otherwise `false`","meta":{"line":472,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L472"}},{"name":"unsubscribe","description":"Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.","access":"private","params":[{"name":"subscription","description":"The subscription to remove","optional":false,"type":[[["PlayerSubscription"]]]}],"returns":[{"types":[[["boolean"]]],"description":"Whether or not the subscription existed on the player and was removed"}],"returnsDescription":"Whether or not the subscription existed on the player and was removed","meta":{"line":290,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L290"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\nFor `EventEmitter`s this behaves exactly the same as calling `.listeners` on\nthe emitter.\n\nFor `EventTarget`s this is the only way to get the event listeners for the\nevent target. This is useful for debugging and diagnostic purposes.\n\n```js\nconst { getEventListeners, EventEmitter } = require('events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  getEventListeners(ee, 'foo'); // [listener]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  getEventListeners(et, 'foo'); // [listener]\n}\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":262,"file":"events.d.ts"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n\n```js\nconst { EventEmitter, listenerCount } = require('events');\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\n```","scope":"static","deprecated":"Since v3.2.0 - Use `listenerCount` instead.","params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":234,"file":"events.d.ts"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n```\n\nReturns an `AsyncIterator` that iterates `eventName` events. It will throw\nif the `EventEmitter` emits `'error'`. It removes all listeners when\nexiting the loop. The `value` returned by each iteration is an array\ncomposed of the emitted event arguments.\n\nAn `AbortSignal` can be used to cancel waiting on events:\n\n```js\nconst { on, EventEmitter } = require('events');\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[{"types":[[["AsyncIterableIterator","<"],["any",">"]]],"description":"that iterates `eventName` events emitted by the `emitter`"}],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.\n\nThis method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\nsemantics and does not listen to the `'error'` event.\n\n```js\nconst { once, EventEmitter } = require('events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.log('error happened', err);\n  }\n}\n\nrun();\n```\n\nThe special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n'`error'` event itself, then it is treated as any other kind of event without\nspecial handling:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.log('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\n```\n\nAn `AbortSignal` can be used to cancel waiting for the event:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[[["Promise","<"],["Array","<"],["any",">>"]]]],"meta":{"line":157,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"```js\nconst {\n  setMaxListeners,\n  EventEmitter\n} = require('events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\n```","scope":"static","params":[{"name":"n","description":"A non-negative number. The maximum number of listeners per `EventTarget` event.","optional":true,"type":[[["number"]]]},{"name":"eventTargets","optional":false,"variable":true,"type":[[["Array","<"],["EventEmitter"," | "],["DOMEventTarget",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":280,"file":"events.d.ts"}}],"events":[{"name":"error","description":"Emitted when there is an error emitted from the audio resource played by the audio player","params":[{"name":"listener","optional":false,"type":[[["("],["error",": "],["AudioPlayerError",") => "],["void"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":159,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L159"}}],"meta":{"line":154,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L154"}},{"name":"AudioPlayerError","description":"An error emitted by an AudioPlayer. Contains an attached resource to aid with\ndebugging and identifying where the error came from.","extends":[[["Error"]]],"construct":{"name":"new AudioPlayerError","params":[{"name":"error","optional":false,"type":[[["Error"]]]},{"name":"resource","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]}]},"props":[{"name":"cause","type":[[["Error"]]],"meta":{"line":26,"file":"lib.es2022.error.d.ts"}},{"name":"message","type":[[["string"]]],"meta":{"line":1029,"file":"lib.es5.d.ts"}},{"name":"name","type":[[["string"]]],"meta":{"line":1028,"file":"lib.es5.d.ts"}},{"name":"resource","description":"The resource associated with the audio player at the time the error was thrown.","readonly":true,"type":[[["AudioResource","<"],["unknown",">"]]],"meta":{"line":11,"file":"AudioPlayerError.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayerError.ts#L11"}},{"name":"stack","type":[[["string"]]],"meta":{"line":1030,"file":"lib.es5.d.ts"}},{"name":"prepareStackTrace","scope":"static","type":[[["("],["err",": "],["Error",", "],["stackTraces",": "],["Array","<"],["CallSite",">) => "],["any"]]],"meta":{"line":11,"file":"globals.d.ts"}},{"name":"stackTraceLimit","scope":"static","type":[[["number"]]],"meta":{"line":13,"file":"globals.d.ts"}}],"methods":[{"name":"captureStackTrace","description":"Create .stack property on a target object","scope":"static","params":[{"name":"targetObject","optional":false,"type":[[["object"]]]},{"name":"constructorOpt","optional":true,"type":[[["Function"]]]}],"returns":[[[["void"]]]],"meta":{"line":4,"file":"globals.d.ts"}}],"meta":{"line":7,"file":"AudioPlayerError.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayerError.ts#L7"}},{"name":"AudioReceiveStream","description":"A readable stream of Opus packets received from a specific entity\nin a Discord voice connection.","extends":[[["Readable"]]],"construct":{"name":"new AudioReceiveStream","params":[{"name":"__namedParameters","optional":false,"type":[[["AudioReceiveStreamOptions"]]]}]},"props":[{"name":"destroyed","description":"Is `true` after `readable.destroy()` has been called.","type":[[["boolean"]]],"meta":{"line":115,"file":"stream.d.ts"}},{"name":"end","description":"The end behavior of the receive stream.","readonly":true,"type":[[["EndBehavior"]]],"meta":{"line":53,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L53"}},{"name":"endTimeout","access":"private","type":[[["Timeout"]]],"meta":{"line":55,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L55"}},{"name":"readable","description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":[[["boolean"]]],"meta":{"line":71,"file":"stream.d.ts"}},{"name":"readableAborted","description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","readonly":true,"type":[[["boolean"]]],"meta":{"line":65,"file":"stream.d.ts"}},{"name":"readableDidRead","description":"Returns whether `'data'` has been emitted.","readonly":true,"type":[[["boolean"]]],"meta":{"line":77,"file":"stream.d.ts"}},{"name":"readableEncoding","description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","readonly":true,"type":[[["null"," | "],["BufferEncoding"]]],"meta":{"line":82,"file":"stream.d.ts"}},{"name":"readableEnded","description":"Becomes `true` when `'end'` event is emitted.","readonly":true,"type":[[["boolean"]]],"meta":{"line":87,"file":"stream.d.ts"}},{"name":"readableFlowing","description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","readonly":true,"type":[[["null"," | "],["boolean"]]],"meta":{"line":93,"file":"stream.d.ts"}},{"name":"readableHighWaterMark","description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","readonly":true,"type":[[["number"]]],"meta":{"line":98,"file":"stream.d.ts"}},{"name":"readableLength","description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","readonly":true,"type":[[["number"]]],"meta":{"line":105,"file":"stream.d.ts"}},{"name":"readableObjectMode","description":"Getter for the property `objectMode` of a given `Readable` stream.","readonly":true,"type":[[["boolean"]]],"meta":{"line":110,"file":"stream.d.ts"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":291,"file":"events.d.ts"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":296,"file":"events.d.ts"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":297,"file":"events.d.ts"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":290,"file":"events.d.ts"}}],"methods":[{"name":"[asyncIterator]","returns":[[[["AsyncIterableIterator","<"],["any",">"]]]],"meta":{"line":479,"file":"stream.d.ts"}},{"name":"_construct","params":[{"name":"callback","optional":false,"type":[[["("],["error",": "],["null"," | "],["Error",") => "],["void"]]]}],"returns":[[[["void"]]]],"meta":{"line":117,"file":"stream.d.ts"}},{"name":"_destroy","params":[{"name":"error","optional":false,"type":[[["null"," | "],["Error"]]]},{"name":"callback","optional":false,"type":[[["("],["error",": "],["null"," | "],["Error",") => "],["void"]]]}],"returns":[[[["void"]]]],"meta":{"line":399,"file":"stream.d.ts"}},{"name":"_read","returns":[[[["void"]]]],"meta":{"line":88,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L88"}},{"name":"addListener","description":"Event emitter\nThe defined events on documents including:\n1. close\n2. data\n3. end\n4. error\n5. pause\n6. readable\n7. resume","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":423,"file":"stream.d.ts"}},{"name":"destroy","description":"Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'`event (unless `emitClose` is set to `false`). After this call, the readable\nstream will release any internal resources and subsequent calls to `push()`will be ignored.\n\nOnce `destroy()` has been called any further calls will be a no-op and no\nfurther errors except from `_destroy()` may be emitted as `'error'`.\n\nImplementors should not override this method, but instead implement `readable._destroy()`.","params":[{"name":"error","description":"Error which will be passed as payload in `'error'` event","optional":true,"type":[[["Error"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":411,"file":"stream.d.ts"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["'close'"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":431,"file":"stream.d.ts"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nconst EventEmitter = require('events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```","returns":[[[["Array","<"],["string"," | "],["symbol",">"]]]],"meta":{"line":632,"file":"events.d.ts"}},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to defaultMaxListeners.","returns":[[[["number"]]]],"meta":{"line":489,"file":"events.d.ts"}},{"name":"isPaused","description":"The `readable.isPaused()` method returns the current operating state of the`Readable`. This is used primarily by the mechanism that underlies the`readable.pipe()` method. In most\ntypical cases, there will be no reason to\nuse this method directly.\n\n```js\nconst readable = new stream.Readable();\n\nreadable.isPaused(); // === false\nreadable.pause();\nreadable.isPaused(); // === true\nreadable.resume();\nreadable.isPaused(); // === false\n```","returns":[[[["boolean"]]]],"meta":{"line":278,"file":"stream.d.ts"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":579,"file":"events.d.ts"}},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":502,"file":"events.d.ts"}},{"name":"off","description":"Alias for `emitter.removeListener()`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":462,"file":"events.d.ts"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":439,"file":"stream.d.ts"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":447,"file":"stream.d.ts"}},{"name":"pause","description":"The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n  readable.pause();\n  console.log('There will be no additional data for 1 second.');\n  setTimeout(() => {\n    console.log('Now data will start flowing again.');\n    readable.resume();\n  }, 1000);\n});\n```\n\nThe `readable.pause()` method has no effect if there is a `'readable'`event listener.","returns":[[[["AudioReceiveStream"]]]],"meta":{"line":242,"file":"stream.d.ts"}},{"name":"pipe","params":[{"name":"destination","optional":false,"type":[[["T"]]]},{"name":"options","optional":true,"type":[[["{"],["\nend",": "],["boolean\n","}"]]]}],"returns":[[[["T"]]]],"meta":{"line":24,"file":"stream.d.ts"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":455,"file":"stream.d.ts"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":463,"file":"stream.d.ts"}},{"name":"push","params":[{"name":"buffer","optional":false,"type":[[["null"," | "],["Buffer"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":66,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L66"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":532,"file":"events.d.ts"}},{"name":"read","description":"The `readable.read()` method pulls some data out of the internal buffer and\nreturns it. If no data available to be read, `null` is returned. By default,\nthe data will be returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.\n\nThe optional `size` argument specifies a specific number of bytes to read. If`size` bytes are not available to be read, `null` will be returned _unless_the stream has ended, in which\ncase all of the data remaining in the internal\nbuffer will be returned.\n\nIf the `size` argument is not specified, all of the data contained in the\ninternal buffer will be returned.\n\nThe `size` argument must be less than or equal to 1 GiB.\n\nThe `readable.read()` method should only be called on `Readable` streams\noperating in paused mode. In flowing mode, `readable.read()` is called\nautomatically until the internal buffer is fully drained.\n\n```js\nconst readable = getReadableStreamSomehow();\n\n// 'readable' may be triggered multiple times as data is buffered in\nreadable.on('readable', () => {\n  let chunk;\n  console.log('Stream is readable (new data received in buffer)');\n  // Use a loop to make sure we read all currently available data\n  while (null !== (chunk = readable.read())) {\n    console.log(`Read ${chunk.length} bytes of data...`);\n  }\n});\n\n// 'end' will be triggered once when there is no more data available\nreadable.on('end', () => {\n  console.log('Reached end of stream.');\n});\n```\n\nEach call to `readable.read()` returns a chunk of data, or `null`. The chunks\nare not concatenated. A `while` loop is necessary to consume all data\ncurrently in the buffer. When reading a large file `.read()` may return `null`,\nhaving consumed all buffered content so far, but there is still more data to\ncome not yet buffered. In this case a new `'readable'` event will be emitted\nwhen there is more data in the buffer. Finally the `'end'` event will be\nemitted when there is no more data to come.\n\nTherefore to read a file's whole contents from a `readable`, it is necessary\nto collect chunks across multiple `'readable'` events:\n\n```js\nconst chunks = [];\n\nreadable.on('readable', () => {\n  let chunk;\n  while (null !== (chunk = readable.read())) {\n    chunks.push(chunk);\n  }\n});\n\nreadable.on('end', () => {\n  const content = chunks.join('');\n});\n```\n\nA `Readable` stream in object mode will always return a single item from\na call to `readable.read(size)`, regardless of the value of the`size` argument.\n\nIf the `readable.read()` method returns a chunk of data, a `'data'` event will\nalso be emitted.\n\nCalling read after the `'end'` event has\nbeen emitted will return `null`. No runtime error will be raised.","params":[{"name":"size","description":"Optional argument to specify how much data to read.","optional":true,"type":[[["number"]]]}],"returns":[[[["any"]]]],"meta":{"line":195,"file":"stream.d.ts"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":473,"file":"events.d.ts"}},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":471,"file":"stream.d.ts"}},{"name":"renewEndTimeout","access":"private","params":[{"name":"end","optional":false,"type":[[["{"],["\nbehavior",": "],["Manual\n","} & {"],["\nduration",": "],["number\n","} & {"],["\nbehavior",": "],["AfterSilence"," | "],["AfterInactivity",","],["\nduration",": "],["number\n","} & {"],["\nduration",": "],["number\n","}"]]]}],"returns":[[[["void"]]]],"meta":{"line":80,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L80"}},{"name":"resume","description":"The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.\n\nThe `readable.resume()` method can be used to fully consume the data from a\nstream without actually processing any of that data:\n\n```js\ngetReadableStreamSomehow()\n  .resume()\n  .on('end', () => {\n    console.log('Reached the end, but did not read anything.');\n  });\n```\n\nThe `readable.resume()` method has no effect if there is a `'readable'`event listener.","returns":[[[["AudioReceiveStream"]]]],"meta":{"line":261,"file":"stream.d.ts"}},{"name":"setEncoding","description":"The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.\n\nBy default, no encoding is assigned and stream data will be returned as`Buffer` objects. Setting an encoding causes the stream data\nto be returned as strings of the specified encoding rather than as `Buffer`objects. For instance, calling `readable.setEncoding('utf8')` will cause the\noutput data to be interpreted as UTF-8 data, and passed as strings. Calling`readable.setEncoding('hex')` will cause the data to be encoded in hexadecimal\nstring format.\n\nThe `Readable` stream will properly handle multi-byte characters delivered\nthrough the stream that would otherwise become improperly decoded if simply\npulled from the stream as `Buffer` objects.\n\n```js\nconst readable = getReadableStreamSomehow();\nreadable.setEncoding('utf8');\nreadable.on('data', (chunk) => {\n  assert.equal(typeof chunk, 'string');\n  console.log('Got %d characters of string data:', chunk.length);\n});\n```","params":[{"name":"encoding","description":"The encoding to use.","optional":false,"type":[[["BufferEncoding"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":220,"file":"stream.d.ts"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":483,"file":"events.d.ts"}},{"name":"unpipe","description":"The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the pipe method.\n\nIf the `destination` is not specified, then _all_ pipes are detached.\n\nIf the `destination` is specified, but no pipe is set up for it, then\nthe method does nothing.\n\n```js\nconst fs = require('fs');\nconst readable = getReadableStreamSomehow();\nconst writable = fs.createWriteStream('file.txt');\n// All the data from readable goes into 'file.txt',\n// but only for the first second.\nreadable.pipe(writable);\nsetTimeout(() => {\n  console.log('Stop writing to file.txt.');\n  readable.unpipe(writable);\n  console.log('Manually close the file stream.');\n  writable.end();\n}, 1000);\n```","params":[{"name":"destination","description":"Optional specific stream to unpipe","optional":true,"type":[[["WritableStream"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":305,"file":"stream.d.ts"}},{"name":"unshift","description":"Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.\n\nThe `readable.unshift()` method pushes a chunk of data back into the internal\nbuffer. This is useful in certain situations where a stream is being consumed by\ncode that needs to \"un-consume\" some amount of data that it has optimistically\npulled out of the source, so that the data can be passed on to some other party.\n\nThe `stream.unshift(chunk)` method cannot be called after the `'end'` event\nhas been emitted or a runtime error will be thrown.\n\nDevelopers using `stream.unshift()` often should consider switching to\nuse of a `Transform` stream instead. See the `API for stream implementers` section for more information.\n\n```js\n// Pull off a header delimited by \\n\\n.\n// Use unshift() if we get too much.\n// Call the callback with (error, header, stream).\nconst { StringDecoder } = require('string_decoder');\nfunction parseHeader(stream, callback) {\n  stream.on('error', callback);\n  stream.on('readable', onReadable);\n  const decoder = new StringDecoder('utf8');\n  let header = '';\n  function onReadable() {\n    let chunk;\n    while (null !== (chunk = stream.read())) {\n      const str = decoder.write(chunk);\n      if (str.match(/\\n\\n/)) {\n        // Found the header boundary.\n        const split = str.split(/\\n\\n/);\n        header += split.shift();\n        const remaining = split.join('\\n\\n');\n        const buf = Buffer.from(remaining, 'utf8');\n        stream.removeListener('error', callback);\n        // Remove the 'readable' listener before unshifting.\n        stream.removeListener('readable', onReadable);\n        if (buf.length)\n          stream.unshift(buf);\n        // Now the body of the message can be read from the stream.\n        callback(null, header, stream);\n      } else {\n        // Still reading the header.\n        header += str;\n      }\n    }\n  }\n}\n```\n\nUnlike push, `stream.unshift(chunk)` will not\nend the reading process by resetting the internal reading state of the stream.\nThis can cause unexpected results if `readable.unshift()` is called during a\nread (i.e. from within a _read implementation on a\ncustom stream). Following the call to `readable.unshift()` with an immediate push will reset the reading state appropriately,\nhowever it is best to simply avoid calling `readable.unshift()` while in the\nprocess of performing a read.","params":[{"name":"chunk","description":"Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must be a string, `Buffer`, `Uint8Array` or `null`. For object mode\nstreams, `chunk` may be any JavaScript value.","optional":false,"type":[[["any"]]]},{"name":"encoding","description":"Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`.","optional":true,"type":[[["BufferEncoding"]]]}],"returns":[[[["void"]]]],"meta":{"line":371,"file":"stream.d.ts"}},{"name":"wrap","description":"Prior to Node.js 0.10, streams did not implement the entire `stream` module API\nas it is currently defined. (See `Compatibility` for more information.)\n\nWhen using an older Node.js library that emits `'data'` events and has a pause method that is advisory only, the`readable.wrap()` method can be used to create a `Readable`\nstream that uses\nthe old stream as its data source.\n\nIt will rarely be necessary to use `readable.wrap()` but the method has been\nprovided as a convenience for interacting with older Node.js applications and\nlibraries.\n\n```js\nconst { OldReader } = require('./old-api-module.js');\nconst { Readable } = require('stream');\nconst oreader = new OldReader();\nconst myReader = new Readable().wrap(oreader);\n\nmyReader.on('readable', () => {\n  myReader.read(); // etc.\n});\n```","params":[{"name":"stream","description":"An \"old style\" readable stream","optional":false,"type":[[["ReadableStream"]]]}],"returns":[[[["AudioReceiveStream"]]]],"meta":{"line":397,"file":"stream.d.ts"}},{"name":"from","description":"A utility method for creating Readable Streams out of iterators.","scope":"static","params":[{"name":"iterable","optional":false,"type":[[["Iterable","<"],["any","> | "],["AsyncIterable","<"],["any",">"]]]},{"name":"options","optional":true,"type":[[["ReadableOptions"]]]}],"returns":[[[["Readable"]]]],"meta":{"line":54,"file":"stream.d.ts"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\nFor `EventEmitter`s this behaves exactly the same as calling `.listeners` on\nthe emitter.\n\nFor `EventTarget`s this is the only way to get the event listeners for the\nevent target. This is useful for debugging and diagnostic purposes.\n\n```js\nconst { getEventListeners, EventEmitter } = require('events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  getEventListeners(ee, 'foo'); // [listener]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  getEventListeners(et, 'foo'); // [listener]\n}\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":262,"file":"events.d.ts"}},{"name":"isDisturbed","description":"Returns whether the stream has been read from or cancelled.","scope":"static","params":[{"name":"stream","optional":false,"type":[[["Readable"," | "],["ReadableStream"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":59,"file":"stream.d.ts"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n\n```js\nconst { EventEmitter, listenerCount } = require('events');\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\n```","scope":"static","deprecated":"Since v3.2.0 - Use `listenerCount` instead.","params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":234,"file":"events.d.ts"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n```\n\nReturns an `AsyncIterator` that iterates `eventName` events. It will throw\nif the `EventEmitter` emits `'error'`. It removes all listeners when\nexiting the loop. The `value` returned by each iteration is an array\ncomposed of the emitted event arguments.\n\nAn `AbortSignal` can be used to cancel waiting on events:\n\n```js\nconst { on, EventEmitter } = require('events');\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[{"types":[[["AsyncIterableIterator","<"],["any",">"]]],"description":"that iterates `eventName` events emitted by the `emitter`"}],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.\n\nThis method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\nsemantics and does not listen to the `'error'` event.\n\n```js\nconst { once, EventEmitter } = require('events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.log('error happened', err);\n  }\n}\n\nrun();\n```\n\nThe special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n'`error'` event itself, then it is treated as any other kind of event without\nspecial handling:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.log('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\n```\n\nAn `AbortSignal` can be used to cancel waiting for the event:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[[["Promise","<"],["Array","<"],["any",">>"]]]],"meta":{"line":157,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"```js\nconst {\n  setMaxListeners,\n  EventEmitter\n} = require('events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\n```","scope":"static","params":[{"name":"n","description":"A non-negative number. The maximum number of listeners per `EventTarget` event.","optional":true,"type":[[["number"]]]},{"name":"eventTargets","optional":false,"variable":true,"type":[[["Array","<"],["EventEmitter"," | "],["DOMEventTarget",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":280,"file":"events.d.ts"}}],"meta":{"line":49,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L49"}},{"name":"AudioResource","description":"Represents an audio resource that can be played by an audio player.","construct":{"name":"new AudioResource","params":[{"name":"edges","optional":false,"type":[[["readonly"," "],["Array","<"],["Edge",">"]]]},{"name":"streams","optional":false,"type":[[["readonly"," "],["Array","<"],["Readable",">"]]]},{"name":"metadata","optional":false,"type":[[["T"]]]},{"name":"silencePaddingFrames","optional":false,"type":[[["number"]]]}]},"props":[{"name":"audioPlayer","description":"The audio player that the resource is subscribed to, if any.","type":[[["AudioPlayer"]]],"meta":{"line":76,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L76"}},{"name":"edges","description":"The pipeline used to convert the input stream into a playable format. For example, this may\ncontain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component\nfor resources with inline volume transformation enabled.","readonly":true,"type":[[["readonly"," "],["Array","<"],["Edge",">"]]],"meta":{"line":54,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L54"}},{"name":"encoder","description":"If using an Opus encoder to create this audio resource, then this will be a prism-media opus.Encoder.\nYou can use this to control settings such as bitrate, FEC, PLP.","readonly":true,"type":[[["Encoder"]]],"meta":{"line":71,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L71"}},{"name":"metadata","description":"Optional metadata that can be used to identify the resource.","type":[[["T"]]],"meta":{"line":59,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L59"}},{"name":"playStream","description":"An object-mode Readable stream that emits Opus packets. This is what is played by audio players.","readonly":true,"type":[[["Readable"]]],"meta":{"line":47,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L47"}},{"name":"playbackDuration","description":"The playback duration of this audio resource, given in milliseconds.","default":"0","type":[[["number"]]],"meta":{"line":81,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L81"}},{"name":"silencePaddingFrames","description":"The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.","readonly":true,"type":[[["number"]]],"meta":{"line":91,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L91"}},{"name":"silenceRemaining","description":"The number of remaining silence frames to play. If -1, the frames have not yet started playing.","default":"-1","type":[[["number"]]],"meta":{"line":96,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L96"}},{"name":"started","description":"Whether or not the stream for this resource has started (data has become readable)","default":"false","type":[[["boolean"]]],"meta":{"line":86,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L86"}},{"name":"volume","description":"If the resource was created with inline volume transformation enabled, then this will be a\nprism-media VolumeTransformer. You can use this to alter the volume of the stream.","readonly":true,"type":[[["VolumeTransformer"]]],"meta":{"line":65,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L65"}}],"methods":[{"name":"read","description":"Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration\nis incremented.","returns":[[[["null"," | "],["Buffer"]]]],"meta":{"line":147,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L147"}}],"meta":{"line":43,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L43"}},{"name":"PlayerSubscription","description":"Represents a subscription of a voice connection to an audio player, allowing\nthe audio player to play audio on the voice connection.","construct":{"name":"new PlayerSubscription","params":[{"name":"connection","optional":false,"type":[[["VoiceConnection"]]]},{"name":"player","optional":false,"type":[[["AudioPlayer"]]]}]},"props":[{"name":"connection","description":"The voice connection of this subscription.","readonly":true,"type":[[["VoiceConnection"]]],"meta":{"line":13,"file":"PlayerSubscription.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/PlayerSubscription.ts#L13"}},{"name":"player","description":"The audio player of this subscription.","readonly":true,"type":[[["AudioPlayer"]]],"meta":{"line":18,"file":"PlayerSubscription.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/PlayerSubscription.ts#L18"}}],"methods":[{"name":"unsubscribe","description":"Unsubscribes the connection from the audio player, meaning that the\naudio player cannot stream audio to it until a new subscription is made.","returns":[[[["void"]]]],"meta":{"line":29,"file":"PlayerSubscription.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/PlayerSubscription.ts#L29"}}],"meta":{"line":9,"file":"PlayerSubscription.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/PlayerSubscription.ts#L9"}},{"name":"SSRCMap","description":"Maps audio SSRCs to data of users in voice connections.","extends":[[["EventEmitter"]]],"construct":{"name":"new SSRCMap"},"props":[{"name":"map","description":"The underlying map.","access":"private","readonly":true,"type":[[["Map","<"],["number",", "],["VoiceUserData",">"]]],"meta":{"line":38,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L38"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":291,"file":"events.d.ts"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":296,"file":"events.d.ts"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":297,"file":"events.d.ts"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":290,"file":"events.d.ts"}}],"methods":[{"name":"addListener","description":"Alias for `emitter.on(eventName, listener)`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":317,"file":"events.d.ts"}},{"name":"delete","description":"Deletes the stored voice data about a user.","params":[{"name":"target","description":"The target of the delete operation, either their audio SSRC or user id","optional":false,"type":[[["string"," | "],["number"]]]}],"returns":[{"types":[[["undefined"," | "],["VoiceUserData"]]],"description":"The data that was deleted, if any"}],"returnsDescription":"The data that was deleted, if any","meta":{"line":89,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L89"}},{"name":"emit","description":"Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nconst EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"args","optional":false,"variable":true,"type":[[["Array","<"],["any",">"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":573,"file":"events.d.ts"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nconst EventEmitter = require('events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```","returns":[[[["Array","<"],["string"," | "],["symbol",">"]]]],"meta":{"line":632,"file":"events.d.ts"}},{"name":"get","description":"Gets the stored voice data of a user.","params":[{"name":"target","description":"The target, either their user id or audio SSRC","optional":false,"type":[[["string"," | "],["number"]]]}],"returns":[[[["undefined"," | "],["VoiceUserData"]]]],"meta":{"line":68,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L68"}},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to defaultMaxListeners.","returns":[[[["number"]]]],"meta":{"line":489,"file":"events.d.ts"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":579,"file":"events.d.ts"}},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":502,"file":"events.d.ts"}},{"name":"off","description":"Alias for `emitter.removeListener()`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":462,"file":"events.d.ts"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["'create'"]]]},{"name":"listener","optional":false,"type":[[["("],["newData",": "],["VoiceUserData",") => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":26,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L26"}},{"name":"once","description":"Adds a **one-time**`listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":377,"file":"events.d.ts"}},{"name":"prependListener","description":"Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\ntimes.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":597,"file":"events.d.ts"}},{"name":"prependOnceListener","description":"Adds a **one-time**`listener` function for the event named `eventName` to the_beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":613,"file":"events.d.ts"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":532,"file":"events.d.ts"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":473,"file":"events.d.ts"}},{"name":"removeListener","description":"Removes the specified `listener` from the listener array for the event named`eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will\nnot remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')`listener is removed:\n\n```js\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":457,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[[["SSRCMap"]]]],"meta":{"line":483,"file":"events.d.ts"}},{"name":"update","description":"Updates the map with new user data","params":[{"name":"data","description":"The data to update with","optional":false,"type":[[["VoiceUserData"]]]}],"returns":[[[["void"]]]],"meta":{"line":50,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L50"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\nFor `EventEmitter`s this behaves exactly the same as calling `.listeners` on\nthe emitter.\n\nFor `EventTarget`s this is the only way to get the event listeners for the\nevent target. This is useful for debugging and diagnostic purposes.\n\n```js\nconst { getEventListeners, EventEmitter } = require('events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  getEventListeners(ee, 'foo'); // [listener]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  getEventListeners(et, 'foo'); // [listener]\n}\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":262,"file":"events.d.ts"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n\n```js\nconst { EventEmitter, listenerCount } = require('events');\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\n```","scope":"static","deprecated":"Since v3.2.0 - Use `listenerCount` instead.","params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":234,"file":"events.d.ts"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n```\n\nReturns an `AsyncIterator` that iterates `eventName` events. It will throw\nif the `EventEmitter` emits `'error'`. It removes all listeners when\nexiting the loop. The `value` returned by each iteration is an array\ncomposed of the emitted event arguments.\n\nAn `AbortSignal` can be used to cancel waiting on events:\n\n```js\nconst { on, EventEmitter } = require('events');\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[{"types":[[["AsyncIterableIterator","<"],["any",">"]]],"description":"that iterates `eventName` events emitted by the `emitter`"}],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.\n\nThis method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\nsemantics and does not listen to the `'error'` event.\n\n```js\nconst { once, EventEmitter } = require('events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.log('error happened', err);\n  }\n}\n\nrun();\n```\n\nThe special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n'`error'` event itself, then it is treated as any other kind of event without\nspecial handling:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.log('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\n```\n\nAn `AbortSignal` can be used to cancel waiting for the event:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[[["Promise","<"],["Array","<"],["any",">>"]]]],"meta":{"line":157,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"```js\nconst {\n  setMaxListeners,\n  EventEmitter\n} = require('events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\n```","scope":"static","params":[{"name":"n","description":"A non-negative number. The maximum number of listeners per `EventTarget` event.","optional":true,"type":[[["number"]]]},{"name":"eventTargets","optional":false,"variable":true,"type":[[["Array","<"],["EventEmitter"," | "],["DOMEventTarget",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":280,"file":"events.d.ts"}}],"meta":{"line":25,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L25"}},{"name":"SpeakingMap","description":"Tracks the speaking states of users in a voice channel.","extends":[[["EventEmitter"]]],"construct":{"name":"new SpeakingMap"},"props":[{"name":"speakingTimeouts","access":"private","readonly":true,"type":[[["Map","<"],["string",", "],["Timeout",">"]]],"meta":{"line":32,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L32"}},{"name":"users","description":"The currently speaking users, mapped to the milliseconds since UNIX epoch at which they started speaking.","readonly":true,"type":[[["Map","<"],["string",", "],["number",">"]]],"meta":{"line":30,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L30"}},{"name":"DELAY","description":"The delay after a packet is received from a user until they're marked as not speaking anymore.","scope":"static","readonly":true,"default":"100","type":[[["100"]]],"meta":{"line":25,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L25"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":291,"file":"events.d.ts"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":296,"file":"events.d.ts"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":297,"file":"events.d.ts"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":290,"file":"events.d.ts"}}],"methods":[{"name":"addListener","description":"Alias for `emitter.on(eventName, listener)`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":317,"file":"events.d.ts"}},{"name":"emit","description":"Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nconst EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"args","optional":false,"variable":true,"type":[[["Array","<"],["any",">"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":573,"file":"events.d.ts"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nconst EventEmitter = require('events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```","returns":[[[["Array","<"],["string"," | "],["symbol",">"]]]],"meta":{"line":632,"file":"events.d.ts"}},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to defaultMaxListeners.","returns":[[[["number"]]]],"meta":{"line":489,"file":"events.d.ts"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":579,"file":"events.d.ts"}},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":502,"file":"events.d.ts"}},{"name":"off","description":"Alias for `emitter.removeListener()`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":462,"file":"events.d.ts"}},{"name":"onPacket","params":[{"name":"userId","optional":false,"type":[[["string"]]]}],"returns":[[[["void"]]]],"meta":{"line":40,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L40"}},{"name":"once","description":"Adds a **one-time**`listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":377,"file":"events.d.ts"}},{"name":"prependListener","description":"Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\ntimes.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":597,"file":"events.d.ts"}},{"name":"prependOnceListener","description":"Adds a **one-time**`listener` function for the event named `eventName` to the_beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":613,"file":"events.d.ts"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":532,"file":"events.d.ts"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":473,"file":"events.d.ts"}},{"name":"removeListener","description":"Removes the specified `listener` from the listener array for the event named`eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will\nnot remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')`listener is removed:\n\n```js\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":457,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":483,"file":"events.d.ts"}},{"name":"startTimeout","access":"private","params":[{"name":"userId","optional":false,"type":[[["string"]]]}],"returns":[[[["void"]]]],"meta":{"line":51,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L51"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\nFor `EventEmitter`s this behaves exactly the same as calling `.listeners` on\nthe emitter.\n\nFor `EventTarget`s this is the only way to get the event listeners for the\nevent target. This is useful for debugging and diagnostic purposes.\n\n```js\nconst { getEventListeners, EventEmitter } = require('events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  getEventListeners(ee, 'foo'); // [listener]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  getEventListeners(et, 'foo'); // [listener]\n}\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":262,"file":"events.d.ts"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n\n```js\nconst { EventEmitter, listenerCount } = require('events');\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\n```","scope":"static","deprecated":"Since v3.2.0 - Use `listenerCount` instead.","params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":234,"file":"events.d.ts"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n```\n\nReturns an `AsyncIterator` that iterates `eventName` events. It will throw\nif the `EventEmitter` emits `'error'`. It removes all listeners when\nexiting the loop. The `value` returned by each iteration is an array\ncomposed of the emitted event arguments.\n\nAn `AbortSignal` can be used to cancel waiting on events:\n\n```js\nconst { on, EventEmitter } = require('events');\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[{"types":[[["AsyncIterableIterator","<"],["any",">"]]],"description":"that iterates `eventName` events emitted by the `emitter`"}],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.\n\nThis method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\nsemantics and does not listen to the `'error'` event.\n\n```js\nconst { once, EventEmitter } = require('events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.log('error happened', err);\n  }\n}\n\nrun();\n```\n\nThe special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n'`error'` event itself, then it is treated as any other kind of event without\nspecial handling:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.log('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\n```\n\nAn `AbortSignal` can be used to cancel waiting for the event:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[[["Promise","<"],["Array","<"],["any",">>"]]]],"meta":{"line":157,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"```js\nconst {\n  setMaxListeners,\n  EventEmitter\n} = require('events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\n```","scope":"static","params":[{"name":"n","description":"A non-negative number. The maximum number of listeners per `EventTarget` event.","optional":true,"type":[[["number"]]]},{"name":"eventTargets","optional":false,"variable":true,"type":[[["Array","<"],["EventEmitter"," | "],["DOMEventTarget",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":280,"file":"events.d.ts"}}],"events":[{"name":"start","description":"Emitted when a user starts speaking.","params":[{"name":"listener","optional":false,"type":[[["("],["userId",": "],["string",") => "],["void"]]]}],"returns":[[[["SpeakingMap"]]]],"meta":{"line":9,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L9"}}],"meta":{"line":4,"file":"SpeakingMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SpeakingMap.ts#L4"}},{"name":"VoiceConnection","description":"A connection to the voice server of a Guild, can be used to play audio in voice channels.","extends":[[["EventEmitter"]]],"construct":{"name":"new VoiceConnection","description":"Creates a new voice connection.","params":[{"name":"joinConfig","description":"The data required to establish the voice connection","optional":false,"type":[[["JoinConfig"]]]},{"name":"options","description":"The options used to create this voice connection","optional":false,"type":[[["CreateVoiceConnectionOptions"]]]}]},"props":[{"name":"_state","description":"The state of the voice connection.","access":"private","type":[[["VoiceConnectionState"]]],"meta":{"line":204,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L204"}},{"name":"debug","description":"The debug logger function, if debugging is enabled.","access":"private","readonly":true,"type":[[["null"," | ("],["message",": "],["string",") => "],["void"]]],"meta":{"line":231,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L231"}},{"name":"joinConfig","description":"A configuration storing all the data needed to reconnect to a Guild's voice server.","readonly":true,"type":[[["JoinConfig"]]],"meta":{"line":211,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L211"}},{"name":"packets","description":"The two packets needed to successfully establish a voice connection. They are received\nfrom the main Discord gateway after signalling to change the voice state.","access":"private","readonly":true,"type":[[["{"],["\nserver",": "],["undefined"," | "],["GatewayVoiceServerUpdateDispatchData",","],["\nstate",": "],["undefined"," | "],["GatewayVoiceState\n","}"]]],"meta":{"line":217,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L217"}},{"name":"receiver","description":"The receiver of this voice connection. You should join the voice channel with `selfDeaf` set\nto false for this feature to work properly.","readonly":true,"type":[[["VoiceReceiver"]]],"meta":{"line":226,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L226"}},{"name":"rejoinAttempts","description":"The number of consecutive rejoin attempts. Initially 0, and increments for each rejoin.\nWhen a connection is successfully established, it resets to 0.","type":[[["number"]]],"meta":{"line":199,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L199"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":291,"file":"events.d.ts"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":296,"file":"events.d.ts"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":297,"file":"events.d.ts"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.\n\nInstalling a listener using this symbol does not change the behavior once an\n`'error'` event is emitted, therefore the process will still crash if no\nregular `'error'` listener is installed.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":290,"file":"events.d.ts"}}],"methods":[{"name":"addListener","description":"Alias for `emitter.on(eventName, listener)`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":317,"file":"events.d.ts"}},{"name":"addServerPacket","description":"Registers a `VOICE_SERVER_UPDATE` packet to the voice connection. This will cause it to reconnect using the\nnew data provided in the packet.","access":"private","params":[{"name":"packet","description":"The received `VOICE_SERVER_UPDATE` packet","optional":false,"type":[[["GatewayVoiceServerUpdateDispatchData"]]]}],"returns":[[[["void"]]]],"meta":{"line":330,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L330"}},{"name":"addStatePacket","description":"Registers a `VOICE_STATE_UPDATE` packet to the voice connection. Most importantly, it stores the id of the\nchannel that the client is connected to.","access":"private","params":[{"name":"packet","description":"The received `VOICE_STATE_UPDATE` packet","optional":false,"type":[[["GatewayVoiceState"]]]}],"returns":[[[["void"]]]],"meta":{"line":349,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L349"}},{"name":"configureNetworking","description":"Attempts to configure a networking instance for this voice connection using the received packets.\nBoth packets are required, and any existing networking instance will be destroyed.","returns":[[[["void"]]]],"meta":{"line":399,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L399"}},{"name":"destroy","description":"Destroys the VoiceConnection, preventing it from connecting to voice again.\nThis method should be called when you no longer require the VoiceConnection to\nprevent memory leaks.","params":[{"name":"adapterAvailable","description":"Whether the adapter can be used","optional":true,"default":"true","type":[[["boolean"]]]}],"returns":[[[["void"]]]],"meta":{"line":547,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L547"}},{"name":"disconnect","description":"Disconnects the VoiceConnection, allowing the possibility of rejoining later on.","returns":[{"types":[[["boolean"]]],"description":"`true` if the connection was successfully disconnected"}],"returnsDescription":"`true` if the connection was successfully disconnected","meta":{"line":567,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L567"}},{"name":"dispatchAudio","description":"Dispatches the previously prepared audio packet (if any)","returns":[[[["undefined"," | "],["boolean"]]]],"meta":{"line":522,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L522"}},{"name":"emit","description":"Synchronously calls each of the listeners registered for the event named`eventName`, in the order they were registered, passing the supplied arguments\nto each.\n\nReturns `true` if the event had listeners, `false` otherwise.\n\n```js\nconst EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\n\n// First listener\nmyEmitter.on('event', function firstListener() {\n  console.log('Helloooo! first listener');\n});\n// Second listener\nmyEmitter.on('event', function secondListener(arg1, arg2) {\n  console.log(`event with parameters ${arg1}, ${arg2} in second listener`);\n});\n// Third listener\nmyEmitter.on('event', function thirdListener(...args) {\n  const parameters = args.join(', ');\n  console.log(`event with parameters ${parameters} in third listener`);\n});\n\nconsole.log(myEmitter.listeners('event'));\n\nmyEmitter.emit('event', 1, 2, 3, 4, 5);\n\n// Prints:\n// [\n//   [Function: firstListener],\n//   [Function: secondListener],\n//   [Function: thirdListener]\n// ]\n// Helloooo! first listener\n// event with parameters 1, 2 in second listener\n// event with parameters 1, 2, 3, 4, 5 in third listener\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"args","optional":false,"variable":true,"type":[[["Array","<"],["any",">"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":573,"file":"events.d.ts"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.\n\n```js\nconst EventEmitter = require('events');\nconst myEE = new EventEmitter();\nmyEE.on('foo', () => {});\nmyEE.on('bar', () => {});\n\nconst sym = Symbol('symbol');\nmyEE.on(sym, () => {});\n\nconsole.log(myEE.eventNames());\n// Prints: [ 'foo', 'bar', Symbol(symbol) ]\n```","returns":[[[["Array","<"],["string"," | "],["symbol",">"]]]],"meta":{"line":632,"file":"events.d.ts"}},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to defaultMaxListeners.","returns":[[[["number"]]]],"meta":{"line":489,"file":"events.d.ts"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":579,"file":"events.d.ts"}},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\n```js\nserver.on('connection', (stream) => {\n  console.log('someone connected!');\n});\nconsole.log(util.inspect(server.listeners('connection')));\n// Prints: [ [Function] ]\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":502,"file":"events.d.ts"}},{"name":"off","description":"Alias for `emitter.removeListener()`.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":462,"file":"events.d.ts"}},{"name":"onNetworkingClose","description":"Called when the networking instance for this connection closes. If the close code is 4014 (do not reconnect),\nthe voice connection will transition to the Disconnected state which will store the close code. You can\ndecide whether or not to reconnect when this occurs by listening for the state change and calling reconnect().","access":"private","params":[{"name":"code","description":"The close code","optional":false,"type":[[["number"]]]}],"returns":[[[["void"]]]],"meta":{"line":438,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L438"}},{"name":"onNetworkingDebug","description":"Propagates debug messages from the underlying network instance.","access":"private","params":[{"name":"message","description":"The debug message to propagate","optional":false,"type":[[["string"]]]}],"returns":[[[["void"]]]],"meta":{"line":504,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L504"}},{"name":"onNetworkingError","description":"Propagates errors from the underlying network instance.","access":"private","params":[{"name":"error","description":"The error to propagate","optional":false,"type":[[["Error"]]]}],"returns":[[[["void"]]]],"meta":{"line":495,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L495"}},{"name":"onNetworkingStateChange","description":"Called when the state of the networking instance changes. This is used to derive the state of the voice connection.","access":"private","params":[{"name":"oldState","description":"The previous state","optional":false,"type":[[["NetworkingState"]]]},{"name":"newState","description":"The new state","optional":false,"type":[[["NetworkingState"]]]}],"returns":[[[["void"]]]],"meta":{"line":471,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L471"}},{"name":"onSubscriptionRemoved","description":"Called when a subscription of this voice connection to an audio player is removed.","access":"private","params":[{"name":"subscription","description":"The removed subscription","optional":false,"type":[[["PlayerSubscription"]]]}],"returns":[[[["void"]]]],"meta":{"line":691,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L691"}},{"name":"once","description":"Adds a **one-time**`listener` function for the event named `eventName`. The\nnext time `eventName` is triggered, this listener is removed and then invoked.\n\n```js\nserver.once('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.\n\nBy default, event listeners are invoked in the order they are added. The`emitter.prependOnceListener()` method can be used as an alternative to add the\nevent listener to the beginning of the listeners array.\n\n```js\nconst myEE = new EventEmitter();\nmyEE.once('foo', () => console.log('a'));\nmyEE.prependOnceListener('foo', () => console.log('b'));\nmyEE.emit('foo');\n// Prints:\n//   b\n//   a\n```","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":377,"file":"events.d.ts"}},{"name":"playOpusPacket","description":"Prepares an audio packet and dispatches it immediately.","params":[{"name":"buffer","description":"The Opus packet to play","optional":false,"type":[[["Buffer"]]]}],"returns":[[[["undefined"," | "],["boolean"]]]],"meta":{"line":533,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L533"}},{"name":"prepareAudioPacket","description":"Prepares an audio packet for dispatch.","params":[{"name":"buffer","description":"The Opus packet to prepare","optional":false,"type":[[["Buffer"]]]}],"returns":[[[["undefined"," | "],["Buffer"]]]],"meta":{"line":513,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L513"}},{"name":"prependListener","description":"Adds the `listener` function to the _beginning_ of the listeners array for the\nevent named `eventName`. No checks are made to see if the `listener` has\nalready been added. Multiple calls passing the same combination of `eventName`and `listener` will result in the `listener` being added, and called, multiple\ntimes.\n\n```js\nserver.prependListener('connection', (stream) => {\n  console.log('someone connected!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":597,"file":"events.d.ts"}},{"name":"prependOnceListener","description":"Adds a **one-time**`listener` function for the event named `eventName` to the_beginning_ of the listeners array. The next time `eventName` is triggered, this\nlistener is removed, and then invoked.\n\n```js\nserver.prependOnceListener('connection', (stream) => {\n  console.log('Ah, we have our first user!');\n});\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","description":"The name of the event.","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","description":"The callback function","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":613,"file":"events.d.ts"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).\n\n```js\nconst emitter = new EventEmitter();\nemitter.once('log', () => console.log('log once'));\n\n// Returns a new Array with a function `onceWrapper` which has a property\n// `listener` which contains the original listener bound above\nconst listeners = emitter.rawListeners('log');\nconst logFnWrapper = listeners[0];\n\n// Logs \"log once\" to the console and does not unbind the `once` event\nlogFnWrapper.listener();\n\n// Logs \"log once\" to the console and removes the listener\nlogFnWrapper();\n\nemitter.on('log', () => console.log('log persistently'));\n// Will return a new Array with a single function bound by `.on()` above\nconst newListeners = emitter.rawListeners('log');\n\n// Logs \"log persistently\" twice\nnewListeners[0]();\nemitter.emit('log');\n```","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":532,"file":"events.d.ts"}},{"name":"rejoin","description":"Attempts to rejoin (better explanation soon:tm:)","params":[{"name":"joinConfig","optional":true,"type":[[["Omit","<"],["JoinConfig",", "],["'group'"," | "],["'guildId'",">"]]]}],"returns":[[[["boolean"]]]],"meta":{"line":602,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L602"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.\n\nIt is bad practice to remove listeners added elsewhere in the code,\nparticularly when the `EventEmitter` instance was created by some other\ncomponent or module (e.g. sockets or file streams).\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":473,"file":"events.d.ts"}},{"name":"removeListener","description":"Removes the specified `listener` from the listener array for the event named`eventName`.\n\n```js\nconst callback = (stream) => {\n  console.log('someone connected!');\n};\nserver.on('connection', callback);\n// ...\nserver.removeListener('connection', callback);\n```\n\n`removeListener()` will remove, at most, one instance of a listener from the\nlistener array. If any single listener has been added multiple times to the\nlistener array for the specified `eventName`, then `removeListener()` must be\ncalled multiple times to remove each instance.\n\nOnce an event is emitted, all listeners attached to it at the\ntime of emitting are called in order. This implies that any`removeListener()` or `removeAllListeners()` calls _after_ emitting and_before_ the last listener finishes execution will\nnot remove them from`emit()` in progress. Subsequent events behave as expected.\n\n```js\nconst myEmitter = new MyEmitter();\n\nconst callbackA = () => {\n  console.log('A');\n  myEmitter.removeListener('event', callbackB);\n};\n\nconst callbackB = () => {\n  console.log('B');\n};\n\nmyEmitter.on('event', callbackA);\n\nmyEmitter.on('event', callbackB);\n\n// callbackA removes listener callbackB but it will still be called.\n// Internal listener array at time of emit [callbackA, callbackB]\nmyEmitter.emit('event');\n// Prints:\n//   A\n//   B\n\n// callbackB is now removed.\n// Internal listener array [callbackA]\nmyEmitter.emit('event');\n// Prints:\n//   A\n```\n\nBecause listeners are managed using an internal array, calling this will\nchange the position indices of any listener registered _after_ the listener\nbeing removed. This will not impact the order in which listeners are called,\nbut it means that any copies of the listener array as returned by\nthe `emitter.listeners()` method will need to be recreated.\n\nWhen a single function has been added as a handler multiple times for a single\nevent (as in the example below), `removeListener()` will remove the most\nrecently added instance. In the example the `once('ping')`listener is removed:\n\n```js\nconst ee = new EventEmitter();\n\nfunction pong() {\n  console.log('pong');\n}\n\nee.on('ping', pong);\nee.once('ping', pong);\nee.removeListener('ping', pong);\n\nee.emit('ping');\nee.emit('ping');\n```\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":457,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.\n\nReturns a reference to the `EventEmitter`, so that calls can be chained.","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":483,"file":"events.d.ts"}},{"name":"setSpeaking","description":"Updates the speaking status of the voice connection. This is used when audio players are done playing audio,\nand need to signal that the connection is no longer playing audio.","params":[{"name":"enabled","description":"Whether or not to show as speaking","optional":false,"type":[[["boolean"]]]}],"returns":[[[["false"," | "],["void"]]]],"meta":{"line":636,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L636"}},{"name":"subscribe","description":"Subscribes to an audio player, allowing the player to play audio on this voice connection.","params":[{"name":"player","description":"The audio player to subscribe to","optional":false,"type":[[["AudioPlayer"]]]}],"returns":[{"types":[[["undefined"," | "],["PlayerSubscription"]]],"description":"The created subscription"}],"returnsDescription":"The created subscription","meta":{"line":648,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L648"}},{"name":"updateReceiveBindings","description":"Called when the networking state changes, and the new ws/udp packet/message handlers need to be rebound\nto the new instances.","access":"private","params":[{"name":"newState","description":"The new networking state","optional":false,"type":[[["NetworkingState"]]]},{"name":"oldState","description":"The old networking state, if there is one","optional":true,"type":[[["NetworkingState"]]]}],"returns":[[[["void"]]]],"meta":{"line":368,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L368"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.\n\nFor `EventEmitter`s this behaves exactly the same as calling `.listeners` on\nthe emitter.\n\nFor `EventTarget`s this is the only way to get the event listeners for the\nevent target. This is useful for debugging and diagnostic purposes.\n\n```js\nconst { getEventListeners, EventEmitter } = require('events');\n\n{\n  const ee = new EventEmitter();\n  const listener = () => console.log('Events are fun');\n  ee.on('foo', listener);\n  getEventListeners(ee, 'foo'); // [listener]\n}\n{\n  const et = new EventTarget();\n  const listener = () => console.log('Events are fun');\n  et.addEventListener('foo', listener);\n  getEventListeners(et, 'foo'); // [listener]\n}\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["Array","<"],["Function",">"]]]],"meta":{"line":262,"file":"events.d.ts"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.\n\n```js\nconst { EventEmitter, listenerCount } = require('events');\nconst myEmitter = new EventEmitter();\nmyEmitter.on('event', () => {});\nmyEmitter.on('event', () => {});\nconsole.log(listenerCount(myEmitter, 'event'));\n// Prints: 2\n```","scope":"static","deprecated":"Since v3.2.0 - Use `listenerCount` instead.","params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[[["number"]]]],"meta":{"line":234,"file":"events.d.ts"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo')) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n```\n\nReturns an `AsyncIterator` that iterates `eventName` events. It will throw\nif the `EventEmitter` emits `'error'`. It removes all listeners when\nexiting the loop. The `value` returned by each iteration is an array\ncomposed of the emitted event arguments.\n\nAn `AbortSignal` can be used to cancel waiting on events:\n\n```js\nconst { on, EventEmitter } = require('events');\nconst ac = new AbortController();\n\n(async () => {\n  const ee = new EventEmitter();\n\n  // Emit later on\n  process.nextTick(() => {\n    ee.emit('foo', 'bar');\n    ee.emit('foo', 42);\n  });\n\n  for await (const event of on(ee, 'foo', { signal: ac.signal })) {\n    // The execution of this inner block is synchronous and it\n    // processes one event at a time (even with await). Do not use\n    // if concurrent execution is required.\n    console.log(event); // prints ['bar'] [42]\n  }\n  // Unreachable here\n})();\n\nprocess.nextTick(() => ac.abort());\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[{"types":[[["AsyncIterableIterator","<"],["any",">"]]],"description":"that iterates `eventName` events emitted by the `emitter`"}],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.\n\nThis method is intentionally generic and works with the web platform [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) interface, which has no special`'error'` event\nsemantics and does not listen to the `'error'` event.\n\n```js\nconst { once, EventEmitter } = require('events');\n\nasync function run() {\n  const ee = new EventEmitter();\n\n  process.nextTick(() => {\n    ee.emit('myevent', 42);\n  });\n\n  const [value] = await once(ee, 'myevent');\n  console.log(value);\n\n  const err = new Error('kaboom');\n  process.nextTick(() => {\n    ee.emit('error', err);\n  });\n\n  try {\n    await once(ee, 'myevent');\n  } catch (err) {\n    console.log('error happened', err);\n  }\n}\n\nrun();\n```\n\nThe special handling of the `'error'` event is only used when `events.once()`is used to wait for another event. If `events.once()` is used to wait for the\n'`error'` event itself, then it is treated as any other kind of event without\nspecial handling:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\n\nonce(ee, 'error')\n  .then(([err]) => console.log('ok', err.message))\n  .catch((err) => console.log('error', err.message));\n\nee.emit('error', new Error('boom'));\n\n// Prints: ok boom\n```\n\nAn `AbortSignal` can be used to cancel waiting for the event:\n\n```js\nconst { EventEmitter, once } = require('events');\n\nconst ee = new EventEmitter();\nconst ac = new AbortController();\n\nasync function foo(emitter, event, signal) {\n  try {\n    await once(emitter, event, { signal });\n    console.log('event emitted!');\n  } catch (error) {\n    if (error.name === 'AbortError') {\n      console.error('Waiting for the event was canceled!');\n    } else {\n      console.error('There was an error', error.message);\n    }\n  }\n}\n\nfoo(ee, 'foo', ac.signal);\nac.abort(); // Abort waiting for the event\nee.emit('foo'); // Prints: Waiting for the event was canceled!\n```","scope":"static","params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[[["Promise","<"],["Array","<"],["any",">>"]]]],"meta":{"line":157,"file":"events.d.ts"}},{"name":"setMaxListeners","description":"```js\nconst {\n  setMaxListeners,\n  EventEmitter\n} = require('events');\n\nconst target = new EventTarget();\nconst emitter = new EventEmitter();\n\nsetMaxListeners(5, target, emitter);\n```","scope":"static","params":[{"name":"n","description":"A non-negative number. The maximum number of listeners per `EventTarget` event.","optional":true,"type":[[["number"]]]},{"name":"eventTargets","optional":false,"variable":true,"type":[[["Array","<"],["EventEmitter"," | "],["DOMEventTarget",">"]]]}],"returns":[[[["void"]]]],"meta":{"line":280,"file":"events.d.ts"}}],"events":[{"name":"error","description":"Emitted when there is an error emitted from the voice connection","params":[{"name":"listener","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":170,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L170"}}],"meta":{"line":165,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L165"}},{"name":"VoiceReceiver","description":"Attaches to a VoiceConnection, allowing you to receive audio packets from other\nusers that are speaking.","construct":{"name":"new VoiceReceiver","params":[{"name":"voiceConnection","optional":false,"type":[[["VoiceConnection"]]]}]},"props":[{"name":"connectionData","description":"The connection data of the receiver.","type":[[["Partial","<"],["ConnectionData",">"]]],"meta":{"line":40,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L40"}},{"name":"speaking","description":"The speaking map of the receiver.","readonly":true,"type":[[["SpeakingMap"]]],"meta":{"line":45,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L45"}},{"name":"ssrcMap","description":"Maps SSRCs to Discord user ids.","readonly":true,"type":[[["SSRCMap"]]],"meta":{"line":28,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L28"}},{"name":"subscriptions","description":"The current audio subscriptions of this receiver.","readonly":true,"type":[[["Map","<"],["string",", "],["AudioReceiveStream",">"]]],"meta":{"line":33,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L33"}},{"name":"voiceConnection","description":"The attached connection of this receiver.","readonly":true,"type":[[["VoiceConnection"]]],"meta":{"line":23,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L23"}}],"methods":[{"name":"decrypt","access":"private","params":[{"name":"buffer","optional":false,"type":[[["Buffer"]]]},{"name":"mode","optional":false,"type":[[["string"]]]},{"name":"nonce","optional":false,"type":[[["Buffer"]]]},{"name":"secretKey","optional":false,"type":[[["Uint8Array"]]]}],"returns":[[[["undefined"," | "],["Buffer"]]]],"meta":{"line":99,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L99"}},{"name":"onUdpMessage","description":"Called when the UDP socket of the attached connection receives a message.","params":[{"name":"msg","description":"The received message","optional":false,"type":[[["Buffer"]]]}],"returns":[[[["void"]]]],"meta":{"line":148,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L148"}},{"name":"onWsPacket","description":"Called when a packet is received on the attached connection's WebSocket.","params":[{"name":"packet","description":"The received packet","optional":false,"type":[[["any"]]]}],"returns":[[[["void"]]]],"meta":{"line":65,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L65"}},{"name":"parsePacket","description":"Parses an audio packet, decrypting it to yield an Opus packet.","access":"private","params":[{"name":"buffer","description":"The buffer to parse","optional":false,"type":[[["Buffer"]]]},{"name":"mode","description":"The encryption mode","optional":false,"type":[[["string"]]]},{"name":"nonce","description":"The nonce buffer used by the connection for encryption","optional":false,"type":[[["Buffer"]]]},{"name":"secretKey","description":"The secret key used by the connection for encryption","optional":false,"type":[[["Uint8Array"]]]}],"returns":[{"types":[[["undefined"," | "],["Buffer"]]],"description":"The parsed Opus packet"}],"returnsDescription":"The parsed Opus packet","meta":{"line":128,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L128"}},{"name":"subscribe","description":"Creates a subscription for the given user id.","params":[{"name":"userId","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["Partial","<"],["AudioReceiveStreamOptions",">"]]]}],"returns":[{"types":[[["AudioReceiveStream"]]],"description":"A readable stream of Opus packets received from the target"}],"returnsDescription":"A readable stream of Opus packets received from the target","meta":{"line":182,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L182"}}],"meta":{"line":19,"file":"VoiceReceiver.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/VoiceReceiver.ts#L19"}}],"functions":[{"name":"createAudioPlayer","description":"Creates a new AudioPlayer to be used.","params":[{"name":"options","optional":true,"type":[[["CreateAudioPlayerOptions"]]]}],"returns":[[[["AudioPlayer"]]]],"meta":{"line":638,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L638"}},{"name":"createAudioResource","description":"Creates an audio resource that can be played by audio players.","params":[{"name":"input","description":"The resource to play","optional":false,"type":[[["string"," | "],["Readable"]]]},{"name":"options","description":"Configurable options for creating the resource","optional":false,"type":[[["CreateAudioResourceOptions","<"],["T","> & "],["Pick","<"],["T"," "],["extends"," "],["undefined"," | "],["null"," ? "],["CreateAudioResourceOptions","<"],["T","> : "],["Required","<"],["CreateAudioResourceOptions","<"],["T",">>, "],["'metadata'",">"]]]}],"returns":[[[["AudioResource","<"],["T"," "],["extends"," "],["null"," | "],["undefined"," ? "],["null"," : "],["T",">"]]]],"meta":{"line":209,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L209"}},{"name":"createDefaultAudioReceiveStreamOptions","returns":[[[["AudioReceiveStreamOptions"]]]],"meta":{"line":37,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L37"}},{"name":"demuxProbe","description":"Attempt to probe a readable stream to figure out whether it can be demuxed using an Ogg or WebM Opus demuxer.","params":[{"name":"stream","description":"The readable stream to probe","optional":false,"type":[[["Readable"]]]},{"name":"probeSize","description":"The number of bytes to attempt to read before giving up on the probe","optional":true,"default":"1024","type":[[["number"]]]},{"name":"validator","description":"The Opus Head validator function","optional":true,"default":"validateDiscordOpusHead","type":[[["("],["opusHead",": "],["Buffer",") => "],["boolean"]]]}],"returns":[[[["Promise","<"],["ProbeInfo",">"]]]],"meta":{"line":44,"file":"demuxProbe.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/demuxProbe.ts#L44"}},{"name":"entersState","description":"Allows a voice connection a specified amount of time to enter a given state, otherwise rejects with an error.","params":[{"name":"target","description":"The voice connection that we want to observe the state change for","optional":false,"type":[[["VoiceConnection"]]]},{"name":"status","description":"The status that the voice connection should be in","optional":false,"type":[[["VoiceConnectionStatus"]]]},{"name":"timeoutOrSignal","description":"The maximum time we are allowing for this to occur, or a signal that will abort the operation","optional":false,"type":[[["number"," | "],["AbortSignal"]]]}],"returns":[[[["Promise","<"],["VoiceConnection",">"]]]],"meta":{"line":13,"file":"entersState.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/entersState.ts#L13"}},{"name":"generateDependencyReport","description":"Generates a report of the dependencies used by the @discordjs/voice module.\nUseful for debugging.","returns":[[[["string"]]]],"meta":{"line":55,"file":"generateDependencyReport.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/generateDependencyReport.ts#L55"}},{"name":"getGroups","description":"Retrieves the map of group names to maps of voice connections. By default, all voice connections\nare created under the 'default' group.","returns":[{"types":[[["Map","<"],["string",", "],["Map","<"],["string",", "],["VoiceConnection",">>"]]],"description":"The group map"}],"returnsDescription":"The group map","meta":{"line":49,"file":"DataStore.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/DataStore.ts#L49"}},{"name":"getVoiceConnection","description":"Finds a voice connection with the given guild id and group. Defaults to the 'default' group.","params":[{"name":"guildId","description":"The guild id of the voice connection","optional":false,"type":[[["string"]]]},{"name":"group","description":"the group that the voice connection was registered with","optional":true,"default":"'default'","type":[[["string"]]]}],"returns":[{"types":[[["undefined"," | "],["VoiceConnection"]]],"description":"The voice connection, if it exists"}],"returnsDescription":"The voice connection, if it exists","meta":{"line":90,"file":"DataStore.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/DataStore.ts#L90"}},{"name":"getVoiceConnections","description":"Retrieves all the voice connections under the 'default' group.","params":[{"name":"group","description":"The group to look up","optional":true,"type":[[["'default'"]]]}],"returns":[{"types":[[["Map","<"],["string",", "],["VoiceConnection",">"]]],"description":"The map of voice connections"}],"returnsDescription":"The map of voice connections","meta":{"line":60,"file":"DataStore.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/DataStore.ts#L60"}},{"name":"joinVoiceChannel","description":"Creates a VoiceConnection to a Discord voice channel.","params":[{"name":"options","description":"the options for joining the voice channel","optional":false,"type":[[["JoinVoiceChannelOptions"," & "],["CreateVoiceConnectionOptions"]]]}],"returns":[[[["VoiceConnection"]]]],"meta":{"line":54,"file":"joinVoiceChannel.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/joinVoiceChannel.ts#L54"}},{"name":"validateDiscordOpusHead","description":"Takes an Opus Head, and verifies whether the associated Opus audio is suitable to play in a Discord voice channel.","params":[{"name":"opusHead","description":"The Opus Head to validate","optional":false,"type":[[["Buffer"]]]}],"returns":[{"types":[[["boolean"]]],"description":"`true` if suitable to play in a Discord voice channel, otherwise `false`"}],"returnsDescription":"`true` if suitable to play in a Discord voice channel, otherwise `false`","meta":{"line":13,"file":"demuxProbe.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/demuxProbe.ts#L13"}}],"interfaces":[],"typedefs":[{"name":"AudioPlayerStatus","meta":{"line":34,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L34"},"props":[{"name":"AutoPaused","description":"When the player has paused itself. Only possible with the \"pause\" no subscriber behavior.","type":[[["autopaused"]]]},{"name":"Buffering","description":"When the player is waiting for an audio resource to become readable before transitioning to Playing.","type":[[["buffering"]]]},{"name":"Idle","description":"When there is currently no resource for the player to be playing.","type":[[["idle"]]]},{"name":"Paused","description":"When the player has been manually paused.","type":[[["paused"]]]},{"name":"Playing","description":"When the player is actively playing an audio resource.","type":[[["playing"]]]}]},{"name":"EndBehaviorType","description":"The different behaviors an audio receive stream can have for deciding when to end.","meta":{"line":7,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L7"},"props":[{"name":"AfterInactivity","description":"The stream will end after a given time period of no audio packets.","type":[[[2]]]},{"name":"AfterSilence","description":"The stream will end after a given time period of silence/no audio packets.","type":[[[1]]]},{"name":"Manual","description":"The stream will only end when manually destroyed.","type":[[[0]]]}]},{"name":"NoSubscriberBehavior","description":"Describes the behavior of the player when an audio packet is played but there are no available\nvoice connections to play to.","meta":{"line":17,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L17"},"props":[{"name":"Pause","description":"Pauses playing the stream until a voice connection becomes available.","type":[[["pause"]]]},{"name":"Play","description":"Continues to play through the resource regardless.","type":[[["play"]]]},{"name":"Stop","description":"The player stops and enters the Idle state.","type":[[["stop"]]]}]},{"name":"StreamType","description":"The different types of stream that can exist within the pipeline.","meta":{"line":35,"file":"TransformerGraph.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/TransformerGraph.ts#L35"},"props":[{"name":"Arbitrary","type":[[["arbitrary"]]]},{"name":"OggOpus","type":[[["ogg/opus"]]]},{"name":"Opus","type":[[["opus"]]]},{"name":"Raw","type":[[["raw"]]]},{"name":"WebmOpus","type":[[["webm/opus"]]]}]},{"name":"VoiceConnectionDisconnectReason","description":"The reasons a voice connection can be in the disconnected state.","meta":{"line":63,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L63"},"props":[{"name":"AdapterUnavailable","description":"When the adapter was unable to send a message requested by the VoiceConnection.","type":[[[1]]]},{"name":"EndpointRemoved","description":"When a VOICE_SERVER_UPDATE packet is received with a null endpoint, causing the connection to be severed.","type":[[[2]]]},{"name":"Manual","description":"When a manual disconnect was requested.","type":[[[3]]]},{"name":"WebSocketClose","description":"When the WebSocket connection has been closed.","type":[[[0]]]}]},{"name":"VoiceConnectionStatus","description":"The various status codes a voice connection can hold at any one time.","meta":{"line":23,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L23"},"props":[{"name":"Connecting","description":"The `VOICE_SERVER_UPDATE` and `VOICE_STATE_UPDATE` packets have been received, now attempting to establish a voice connection.","type":[[["connecting"]]]},{"name":"Destroyed","description":"The voice connection has been destroyed and untracked, it cannot be reused.","type":[[["destroyed"]]]},{"name":"Disconnected","description":"The voice connection has either been severed or not established.","type":[[["disconnected"]]]},{"name":"Ready","description":"A voice connection has been established, and is ready to be used.","type":[[["ready"]]]},{"name":"Signalling","description":"Sending a packet to the main Discord gateway to indicate we want to change our voice state.","type":[[["signalling"]]]}]},{"name":"AudioPlayerBufferingState","description":"The state that an AudioPlayer is in when it is waiting for a resource to become readable. Once this\nhappens, the AudioPlayer will enter the Playing state. If the resource ends/errors before this, then\nit will re-enter the Idle state.","meta":{"line":84,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L84"},"props":[{"name":"onFailureCallback","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onReadableCallback","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]},{"name":"resource","description":"The resource that the AudioPlayer is waiting for","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"status","optional":false,"type":[[["Buffering"]]]}]},{"name":"AudioPlayerIdleState","description":"The state that an AudioPlayer is in when it has no resource to play. This is the starting state.","meta":{"line":75,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L75"},"props":[{"name":"status","optional":false,"type":[[["Idle"]]]}]},{"name":"AudioPlayerPausedState","description":"The state that an AudioPlayer is in when it has either been explicitly paused by the user, or done\nautomatically by the AudioPlayer itself if there are no available subscribers.","meta":{"line":124,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L124"},"props":[{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]},{"name":"playbackDuration","description":"The playback duration in milliseconds of the current audio resource. This includes filler silence packets\nthat have been played when the resource was buffering.","optional":false,"type":[[["number"]]]},{"name":"resource","description":"The current resource of the audio player.","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"silencePacketsRemaining","description":"How many silence packets still need to be played to avoid audio interpolation due to the stream suddenly pausing.","optional":false,"type":[[["number"]]]},{"name":"status","optional":false,"type":[[["Paused"," | "],["AutoPaused"]]]}]},{"name":"AudioPlayerPlayingState","description":"The state that an AudioPlayer is in when it is actively playing an AudioResource. When playback ends,\nit will enter the Idle state.","meta":{"line":99,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L99"},"props":[{"name":"missedFrames","description":"The number of consecutive times that the audio resource has been unable to provide an Opus frame.","optional":false,"type":[[["number"]]]},{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]},{"name":"playbackDuration","description":"The playback duration in milliseconds of the current audio resource. This includes filler silence packets\nthat have been played when the resource was buffering.","optional":false,"type":[[["number"]]]},{"name":"resource","description":"The resource that is being played.","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"status","optional":false,"type":[[["Playing"]]]}]},{"name":"AudioReceiveStreamOptions","meta":{"line":33,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L33"},"props":[{"name":"autoDestroy","optional":true,"type":[[["boolean"]]]},{"name":"emitClose","optional":true,"type":[[["boolean"]]]},{"name":"encoding","optional":true,"type":[[["BufferEncoding"]]]},{"name":"end","optional":false,"type":[[["EndBehavior"]]]},{"name":"highWaterMark","optional":true,"type":[[["number"]]]},{"name":"objectMode","optional":true,"type":[[["boolean"]]]},{"name":"signal","description":"When provided the corresponding `AbortController` can be used to cancel an asynchronous action.","optional":true,"type":[[["AbortSignal"]]]},{"name":"construct","optional":true,"type":[[["("],["this",": "],["Readable",", "],["callback",": ("],["error",": "],["null"," | "],["Error",") => "],["void",") => "],["void"]]]},{"name":"destroy","optional":true,"type":[[["("],["this",": "],["Readable",", "],["error",": "],["null"," | "],["Error",", "],["callback",": ("],["error",": "],["null"," | "],["Error",") => "],["void",") => "],["void"]]]},{"name":"read","optional":true,"type":[[["("],["this",": "],["Readable",", "],["size",": "],["number",") => "],["void"]]]}]},{"name":"CreateAudioPlayerOptions","description":"Options that can be passed when creating an audio player, used to specify its behavior.","meta":{"line":64,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L64"},"props":[{"name":"behaviors","optional":true,"type":[[["{"],["\nmaxMissedFrames",": "],["number",","],["\nnoSubscriber",": "],["NoSubscriberBehavior\n","}"]]]},{"name":"debug","optional":true,"type":[[["boolean"]]]}]},{"name":"CreateAudioResourceOptions","description":"Options that are set when creating a new audio resource.","meta":{"line":12,"file":"AudioResource.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioResource.ts#L12"},"props":[{"name":"inlineVolume","description":"Whether or not inline volume should be enabled. If enabled, you will be able to change the volume\nof the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.","optional":true,"type":[[["boolean"]]]},{"name":"inputType","description":"The type of the input stream. Defaults to `StreamType.Arbitrary`.","optional":true,"type":[[["StreamType"]]]},{"name":"metadata","description":"Optional metadata that can be attached to the resource (e.g. track title, random id).\nThis is useful for identification purposes when the resource is passed around in events.\nSee metadata","optional":true,"type":[[["T"]]]},{"name":"silencePaddingFrames","description":"The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\nDefaults to 5.","optional":true,"type":[[["number"]]]}]},{"name":"CreateVoiceConnectionOptions","description":"The options that can be given when creating a voice connection.","meta":{"line":8,"file":"joinVoiceChannel.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/joinVoiceChannel.ts#L8"},"props":[{"name":"adapterCreator","optional":false,"type":[[["DiscordGatewayAdapterCreator"]]]},{"name":"debug","description":"If true, debug messages will be enabled for the voice connection and its\nrelated components. Defaults to false.","optional":true,"type":[[["boolean"]]]}]},{"name":"DiscordGatewayAdapterImplementerMethods","description":"Methods that are provided by the implementer of a Discord gateway DiscordGatewayAdapter.","meta":{"line":29,"file":"adapter.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/adapter.ts#L29"},"props":[{"name":"destroy","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"sendPayload","optional":false,"type":[[["("],["payload",": "],["any",") => "],["boolean"]]]}]},{"name":"DiscordGatewayAdapterLibraryMethods","description":"Methods that are provided by the @discordjs/voice library to implementations of\nDiscord gateway DiscordGatewayAdapters.","meta":{"line":7,"file":"adapter.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/adapter.ts#L7"},"props":[{"name":"destroy","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onVoiceServerUpdate","optional":false,"type":[[["("],["data",": "],["GatewayVoiceServerUpdateDispatchData",") => "],["void"]]]},{"name":"onVoiceStateUpdate","optional":false,"type":[[["("],["data",": "],["GatewayVoiceState",") => "],["void"]]]}]},{"name":"JoinConfig","meta":{"line":5,"file":"DataStore.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/DataStore.ts#L5"},"props":[{"name":"channelId","optional":false,"type":[[["null"," | "],["string"]]]},{"name":"group","optional":false,"type":[[["string"]]]},{"name":"guildId","optional":false,"type":[[["string"]]]},{"name":"selfDeaf","optional":false,"type":[[["boolean"]]]},{"name":"selfMute","optional":false,"type":[[["boolean"]]]}]},{"name":"JoinVoiceChannelOptions","description":"The options that can be given when joining a voice channel.","meta":{"line":21,"file":"joinVoiceChannel.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/joinVoiceChannel.ts#L21"},"props":[{"name":"channelId","description":"The id of the Discord voice channel to join.","optional":false,"type":[[["string"]]]},{"name":"group","description":"An optional group identifier for the voice connection.","optional":true,"type":[[["string"]]]},{"name":"guildId","description":"The id of the guild that the voice channel belongs to.","optional":false,"type":[[["string"]]]},{"name":"selfDeaf","description":"Whether to join the channel deafened (defaults to true)","optional":true,"type":[[["boolean"]]]},{"name":"selfMute","description":"Whether to join the channel muted (defaults to true)","optional":true,"type":[[["boolean"]]]}]},{"name":"ProbeInfo","description":"The resulting information after probing an audio stream","meta":{"line":22,"file":"demuxProbe.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/demuxProbe.ts#L22"},"props":[{"name":"stream","description":"The readable audio stream to use. You should use this rather than the input stream, as the probing\nfunction can sometimes read the input stream to its end and cause the stream to close.","optional":false,"type":[[["Readable"]]]},{"name":"type","description":"The recommended stream type for this audio stream.","optional":false,"type":[[["StreamType"]]]}]},{"name":"VoiceConnectionConnectingState","description":"The state that a VoiceConnection will be in when it is establishing a connection to a Discord\nvoice server.","meta":{"line":128,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L128"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"networking","optional":false,"type":[[["Networking"]]]},{"name":"status","optional":false,"type":[[["Connecting"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDestroyedState","description":"The state that a VoiceConnection will be in when it has been permanently been destroyed by the\nuser and untracked by the library. It cannot be reconnected, instead, a new VoiceConnection\nneeds to be established.","meta":{"line":151,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L151"},"props":[{"name":"status","optional":false,"type":[[["Destroyed"]]]}]},{"name":"VoiceConnectionDisconnectedBaseState","description":"The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":89,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L89"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDisconnectedOtherState","description":"The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":99,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L99"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"reason","optional":false,"type":[[["AdapterUnavailable"," | "],["EndpointRemoved"," | "],["Manual"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDisconnectedWebSocketState","description":"The state that a VoiceConnection will be in when its WebSocket connection was closed.\nYou can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":107,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L107"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"closeCode","description":"The close code of the WebSocket connection to the Discord voice server.","optional":false,"type":[[["number"]]]},{"name":"reason","optional":false,"type":[[["WebSocketClose"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionReadyState","description":"The state that a VoiceConnection will be in when it has an active connection to a Discord\nvoice server.","meta":{"line":139,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L139"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"networking","optional":false,"type":[[["Networking"]]]},{"name":"status","optional":false,"type":[[["Ready"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionSignallingState","description":"The state that a VoiceConnection will be in when it is waiting to receive a VOICE_SERVER_UPDATE and\nVOICE_STATE_UPDATE packet from Discord, provided by the adapter.","meta":{"line":54,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L54"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"status","optional":false,"type":[[["Signalling"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceUserData","description":"The known data for a user in a Discord voice connection.","meta":{"line":7,"file":"SSRCMap.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/SSRCMap.ts#L7"},"props":[{"name":"audioSSRC","description":"The SSRC of the user's audio stream.","optional":false,"type":[[["number"]]]},{"name":"userId","description":"The Discord user id of the user.","optional":false,"type":[[["string"]]]},{"name":"videoSSRC","description":"The SSRC of the user's video stream (if one exists)\nCannot be 0. If undefined, the user has no video stream.","optional":true,"type":[[["number"]]]}]},{"name":"AudioPlayerState","description":"The various states that the player can be in.","type":[[["AudioPlayerIdleState"," | "],["AudioPlayerBufferingState"," | "],["AudioPlayerPlayingState"," | "],["AudioPlayerPausedState"]]],"meta":{"line":148,"file":"AudioPlayer.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/audio/AudioPlayer.ts#L148"}},{"name":"DiscordGatewayAdapterCreator","description":"A function used to build adapters. It accepts a methods parameter that contains functions that\ncan be called by the implementer when new data is received on its gateway connection. In return,\nthe implementer will return some methods that the library can call - e.g. to send messages on\nthe gateway, or to signal that the adapter can be removed.","type":[[["("],["methods",": "],["DiscordGatewayAdapterLibraryMethods",") => "],["DiscordGatewayAdapterImplementerMethods"]]],"meta":{"line":51,"file":"adapter.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/util/adapter.ts#L51"},"params":[{"name":"methods","optional":false,"type":[[["DiscordGatewayAdapterLibraryMethods"]]]}],"returns":[[[["DiscordGatewayAdapterImplementerMethods"]]]]},{"name":"EndBehavior","type":[[["{"],["\nbehavior",": "],["EndBehaviorTypeManual\n","} | {"],["\nbehavior",": "],["EndBehaviorTypeAfterSilence"," | "],["EndBehaviorTypeAfterInactivity",","],["\nduration",": "],["number\n","}"]]],"meta":{"line":24,"file":"AudioReceiveStream.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/receive/AudioReceiveStream.ts#L24"}},{"name":"VoiceConnectionDisconnectedState","description":"The states that a VoiceConnection can be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to connect using VoiceConnection#reconnect.","type":[[["VoiceConnectionDisconnectedOtherState"," | "],["VoiceConnectionDisconnectedWebSocketState"]]],"meta":{"line":120,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L120"}},{"name":"VoiceConnectionState","description":"The various states that a voice connection can be in.","type":[[["VoiceConnectionSignallingState"," | "],["VoiceConnectionDisconnectedState"," | "],["VoiceConnectionConnectingState"," | "],["VoiceConnectionReadyState"," | "],["VoiceConnectionDestroyedState"]]],"meta":{"line":158,"file":"VoiceConnection.ts","url":"https://github.com/discordjs/discord.js/blob/41e4e10/packages/voice/src/VoiceConnection.ts#L158"}}],"externals":[],"custom":{"general":{"name":"General","files":{"welcome":{"name":"Welcome","type":"md","content":"<div align=\"center\">\n\t<br />\n\t<p>\n\t\t<a href=\"https://discord.js.org\"><img src=\"https://discord.js.org/static/logo.svg\" width=\"546\" alt=\"discord.js\" /></a>\n\t</p>\n\t<br />\n\t<p>\n\t\t<a href=\"https://discord.gg/djs\"><img src=\"https://img.shields.io/discord/222078108977594368?color=5865F2&logo=discord&logoColor=white\" alt=\"Discord server\" /></a>\n\t\t<a href=\"https://www.npmjs.com/package/@discordjs/voice\"><img src=\"https://img.shields.io/npm/v/@discordjs/voice.svg?maxAge=3600\" alt=\"npm version\" /></a>\n\t\t<a href=\"https://www.npmjs.com/package/@discordjs/voice\"><img src=\"https://img.shields.io/npm/dt/@discordjs/voice.svg?maxAge=3600\" alt=\"npm downloads\" /></a>\n\t\t<a href=\"https://github.com/discordjs/discord.js/actions\"><img src=\"https://github.com/discordjs/discord.js/actions/workflows/test.yml/badge.svg\" alt=\"Build status\" /></a>\n\t\t<a href=\"https://codecov.io/gh/discordjs/discord.js\" ><img src=\"https://codecov.io/gh/discordjs/discord.js/branch/main/graph/badge.svg?precision=2&flag=voice\" alt=\"Code coverage\" /></a>\n\t</p>\n\t<p>\n\t\t<a href=\"https://vercel.com/?utm_source=discordjs&utm_campaign=oss\"><img src=\"https://raw.githubusercontent.com/discordjs/discord.js/main/.github/powered-by-vercel.svg\" alt=\"Vercel\" /></a>\n\t</p>\n</div>\n\n## About\n\nAn implementation of the Discord Voice API for Node.js, written in TypeScript.\n\n**Features:**\n\n- Send and receive\\* audio in Discord voice-based channels\n- A strong focus on reliability and predictable behaviour\n- Horizontal scalability and libraries other than [discord.js](https://discord.js.org/) are supported with custom adapters\n- A robust audio processing system that can handle a wide range of audio sources\n\n\\*_Audio receive is not documented by Discord so stable support is not guaranteed_\n\n## Installation\n\n**Node.js 16.9.0 or newer is required.**\n\n```sh-session\nnpm install @discordjs/voice\nyarn add @discordjs/voice\npnpm add @discordjs/voice\n```\n\n## Dependencies\n\nThis library has several optional dependencies to support a variety\nof different platforms. Install one dependency from each of the\ncategories shown below. The dependencies are listed in order of\npreference for performance. If you can't install one of the options,\ntry installing another.\n\n**Encryption Libraries (npm install):**\n\n- `sodium-native`: ^3.3.0\n- `sodium`: ^3.0.2\n- `tweetnacl`: ^1.0.3\n- `libsodium-wrappers`: ^0.7.9\n\n**Opus Libraries (npm install):**\n\n- `@discordjs/opus`: ^0.4.0\n- `opusscript`: ^0.0.7\n\n**FFmpeg:**\n\n- [`FFmpeg`](https://ffmpeg.org/) (installed and added to environment)\n- `ffmpeg-static`: ^4.2.7 (npm install)\n\n## Links\n\n- [Website](https://discord.js.org/) ([source](https://github.com/discordjs/discord.js/tree/main/packages/website))\n- [Documentation](https://discord.js.org/#/docs/voice)\n- [Guide](https://discordjs.guide/) ([source](https://github.com/discordjs/guide))\n  See also the [Update Guide](https://discordjs.guide/additional-info/changes-in-v13.html), including updated and removed items in the library.\n- [discord.js Discord server](https://discord.gg/djs)\n- [Discord API Discord server](https://discord.gg/discord-api)\n- [GitHub](https://github.com/discordjs/discord.js/tree/main/packages/voice)\n- [npm](https://www.npmjs.com/package/@discordjs/voice)\n- [Related libraries](https://discord.com/developers/docs/topics/community-resources#libraries)\n- [Examples](https://github.com/discordjs/discord.js/tree/main/packages/voice/examples)\n\n## Contributing\n\nBefore creating an issue, please ensure that it hasn't already been reported/suggested, and double-check the\n[documentation](https://discord.js.org/#/docs/voice).  \nSee [the contribution guide](https://github.com/discordjs/discord.js/blob/main/.github/CONTRIBUTING.md) if you'd like to submit a PR.\n\n## Help\n\nIf you don't understand something in the documentation, you are experiencing problems, or you just need a gentle\nnudge in the right direction, please don't hesitate to join our official [discord.js Server](https://discord.gg/djs).\n","path":"README.md"}}}}}